#!/usr/bin/env node

import * as ts from 'typescript';
import fs from 'fs';
import path from 'path';

function getAllTSFiles(dir, files = []) {
  for (const file of fs.readdirSync(dir)) {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      getAllTSFiles(fullPath, files);
    } else if (file.endsWith(".ts")) {
      files.push(fullPath);
    }
  }
  return files;
}

function createProgram(projectRoot) {
  const fileNames = getAllTSFiles(path.join(projectRoot, 'src'));
  return ts.createProgram(fileNames, {
    target: ts.ScriptTarget.ESNext,
    module: ts.ModuleKind.ESNext,
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    allowJs: true,
    checkJs: false,
    jsx: ts.JsxEmit.React
  });
}

function isBuiltIn(typeName) {
  return ['string', 'number', 'boolean', 'any', 'undefined', 'null'].includes(typeName);
}

function flattenType(type, typeChecker, visited = new Set()) {
  if (!type || visited.has(type)) return {};
  visited.add(type);

  if (type.isUnion()) {
    const types = type.types.map(t => typeChecker.typeToString(t));
    return { type: types.join(" | ") };
  }

  const props = {};
  for (const prop of type.getProperties()) {
    const name = prop.getName();
    const propType = typeChecker.getTypeOfSymbolAtLocation(prop, prop.valueDeclaration ?? prop.declarations?.[0]);
    const propTypeStr = typeChecker.typeToString(propType);

    if (propType.getProperties && propType.getProperties().length > 0 && !isBuiltIn(propTypeStr)) {
      const nested = flattenType(propType, typeChecker, visited);
      for (const key in nested) {
        props[`${name}.${key}`] = nested[key];
      }
    } else {
      props[name] = propTypeStr;
    }
  }
  return props;
}

function extractActions(program, projectRoot) {
  const typeChecker = program.getTypeChecker();
  const actions = [];

  for (const sourceFile of program.getSourceFiles()) {
    if (sourceFile.isDeclarationFile || sourceFile.fileName.includes("node_modules")) continue;

    ts.forEachChild(sourceFile, node => {
      if (
        ts.isFunctionDeclaration(node) &&
        node.name &&
        node.modifiers?.some(m => m.kind === ts.SyntaxKind.ExportKeyword)
      ) {
        const text = sourceFile.getFullText();
        const comments = ts.getLeadingCommentRanges(text, node.pos);
        const hasAnnotation = comments?.some(r =>
          text.substring(r.pos, r.end).includes("@abra-action")
        );

        if (hasAnnotation) {
          const parameters = {};
          node.parameters.forEach(param => {
            const paramName = param.name.getText(sourceFile);
            const paramType = typeChecker.getTypeAtLocation(param);
            const flattened = flattenType(paramType, typeChecker);
            for (const key in flattened) {
              parameters[`${paramName}.${key}`] = flattened[key];
            }
          });

          actions.push({
            name: node.name.text,
            description: `Execute ${node.name.text}`,
            parameters,
            module: sourceFile.fileName
          });
        }
      }
    });
  }

  return actions;
}

function generateActionsJson(projectRoot, actions) {
  const out = path.join(projectRoot, 'src/actions/actions.json');
  fs.mkdirSync(path.dirname(out), { recursive: true });
  fs.writeFileSync(out, JSON.stringify({ actions }, null, 2));
  console.log(`✅ actions.json generated at ${out}`);
}

function generateActionRegistry(projectRoot, actions) {
  let imports = '';
  let entries = '';

  actions.forEach(action => {
    const relPath = path.relative(
      path.join(projectRoot, 'src/actions'),
      action.module.replace(/\.ts$/, '')
    ).replace(/\\/g, '/');

    imports += `import { ${action.name} } from '${relPath}';\n`;
    entries += `  ${action.name},\n`;
  });

  const content = `// AUTO-GENERATED BY ABRA CLI — DO NOT EDIT MANUALLY
${imports}
const actionRegistry = {
${entries}};
export default actionRegistry;`;

  const out = path.join(projectRoot, 'src/actions/actionRegistry.js');
  fs.mkdirSync(path.dirname(out), { recursive: true });
  fs.writeFileSync(out, content);
  console.log(`✅ actionRegistry.js generated at ${out}`);
}

function generateExecutor(projectRoot) {
  const content = `// AUTO-GENERATED BY ABRA CLI — DO NOT EDIT MANUALLY
import actionRegistry from './actionRegistry';

export async function executeAction(actionName, params) {
  const actionFn = actionRegistry[actionName];
  if (!actionFn) throw new Error(\`Action "\${actionName}" is not registered.\`);
  try {
    const result = await actionFn(params);
    return { success: true, result };
  } catch (error) {
    return { success: false, error: error.message };
  }
}`;
  const out = path.join(projectRoot, 'src/actions/abra-executor.js');
  fs.mkdirSync(path.dirname(out), { recursive: true });
  fs.writeFileSync(out, content);
  console.log(`✅ abra-executor.js generated at ${out}`);
}

function generateAbraComponent(projectRoot) {
  const content = `// AUTO-GENERATED BY ABRA CLI — DO NOT EDIT MANUALLY
import React, { useState } from "react";
import actionsJson from '../actions/actions.json';
import { executeAction } from '../actions/abra-executor';

const BACKEND_URL = "http://localhost:4000";

export function AbraActionPrompt() {
  const [input, setInput] = useState("");
  const [status, setStatus] = useState("");
  const [result, setResult] = useState(null);
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleExecute = async () => {
    setIsLoading(true); setStatus("Resolving action...");
    try {
      const res = await fetch(\`\${BACKEND_URL}/api/resolve-action\`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userIntent: input, actions: actionsJson.actions })
      });
      const aiResponse = await res.json();
      const executionResult = await executeAction(aiResponse.action, aiResponse.params);
      if (executionResult.success) {
        setResult(executionResult.result);
        setStatus(\`✅ Executed: \${aiResponse.action}\`);
      } else throw new Error(executionResult.error);
    } catch (err) {
      setError(err.message); setStatus("Failed");
    } finally { setIsLoading(false); }
  };

  return (<div className="abra-container">
    <input value={input} onChange={(e) => setInput(e.target.value)} disabled={isLoading} />
    <button onClick={handleExecute} disabled={isLoading}>Execute</button>
    {status && <p>{status}</p>}
    {error && <p>{error}</p>}
    {result && <pre>{JSON.stringify(result, null, 2)}</pre>}
  </div>);
}`;
  const out = path.join(projectRoot, 'src/components/AbraActionPrompt.jsx');
  fs.mkdirSync(path.dirname(out), { recursive: true });
  fs.writeFileSync(out, content);
  console.log(`✅ AbraActionPrompt.jsx generated at ${out}`);
}

const projectRoot = process.argv[2] || process.cwd();
const program = createProgram(projectRoot);
const actions = extractActions(program, projectRoot);
generateActionsJson(projectRoot, actions);
generateActionRegistry(projectRoot, actions);
generateExecutor(projectRoot);
generateAbraComponent(projectRoot);
