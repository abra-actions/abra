#!/usr/bin/env node

import * as ts from 'typescript';
import fs from 'fs';
import path from 'path';

// === File discovery ===
function getAllTSFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);
  for (const file of files) {
    const fullPath = path.join(dir, file);
    if (fs.statSync(fullPath).isDirectory()) {
      getAllTSFiles(fullPath, fileList);
    } else if (file.endsWith('.ts') && !file.endsWith('.d.ts')) {
      fileList.push(fullPath);
    }
  }
  return fileList;
}

// === Helper: is valid exported function with @abra-action ===
function isAbraAction(fn, sourceText) {
  const comments = ts.getLeadingCommentRanges(sourceText, fn.pos);
  return comments?.some(r => sourceText.slice(r.pos, r.end).includes('@abra-action'));
}

// === Helper: flatten custom types into primitives ===
function serializeType(type, checker, seen = new Set()) {
  if (!type || seen.has(type)) return 'any';
  seen.add(type);

  if (type.flags & ts.TypeFlags.String) return 'string';
  if (type.flags & ts.TypeFlags.Number) return 'number';
  if (type.flags & ts.TypeFlags.Boolean) return 'boolean';
  if (type.flags & ts.TypeFlags.Null) return 'null';
  if (type.flags & ts.TypeFlags.Undefined) return 'undefined';
  if (type.flags & ts.TypeFlags.Any || type.flags & ts.TypeFlags.Unknown) return 'any';

  if (type.isUnion()) {
    const literals = type.types.map(t => serializeType(t, checker, new Set(seen)));
    const flattened = literals.flat();
    const isAllLiterals = flattened.every(t => typeof t === 'string' || typeof t === 'number' || typeof t === 'boolean');
    return isAllLiterals ? flattened : 'any';
  }

  if (checker.isArrayType(type)) {
    const elementType = checker.getTypeArguments(type)[0];
    return { type: 'array', items: serializeType(elementType, checker, new Set(seen)) };
  }

  const props = type.getProperties?.();
  if (!props || !props.length) return checker.typeToString(type);

  const result = {};
  for (const prop of props) {
    const propType = checker.getTypeOfSymbolAtLocation(prop, prop.valueDeclaration || prop.declarations[0]);
    result[prop.name] = serializeType(propType, checker, new Set(seen));
  }
  return result;
}

// === CLI Main ===
function main(projectRoot) {
  const files = getAllTSFiles(path.join(projectRoot, 'src'));
  const program = ts.createProgram(files, { allowJs: false });
  const checker = program.getTypeChecker();

  const actions = [];

  for (const sourceFile of program.getSourceFiles()) {
    if (sourceFile.isDeclarationFile || sourceFile.fileName.includes('node_modules')) continue;
    const sourceText = sourceFile.getFullText();

    ts.forEachChild(sourceFile, node => {
      if (ts.isFunctionDeclaration(node) && node.name && node.modifiers?.some(m => m.kind === ts.SyntaxKind.ExportKeyword)) {
        if (!isAbraAction(node, sourceText)) return;

        const fnName = node.name.text;
        const params = {};

        for (const param of node.parameters) {
          const paramName = param.name.getText();
          const paramType = checker.getTypeAtLocation(param);
          params[paramName] = serializeType(paramType, checker);
        }

        actions.push({
          name: fnName,
          description: `Execute ${fnName}`,
          parameters: params,
          module: sourceFile.fileName
        });

        console.log(`✅ Found @abra-action: ${fnName}`);
      }
    });
  }

  writeActionsJson(actions, projectRoot);
  writeActionRegistry(actions, projectRoot);
  writeExecutor(projectRoot);
  writeAbraComponent(projectRoot);
}

// === Writers ===

function writeActionsJson(actions, root) {
  const out = {
    actions,
    typeAliases: {} // future support if needed
  };
  const file = path.join(root, 'src/actions/actions.json');
  fs.mkdirSync(path.dirname(file), { recursive: true });
  fs.writeFileSync(file, JSON.stringify(out, null, 2));
  console.log(`✅ Wrote actions.json`);
}

function writeActionRegistry(actions, root) {
  let imports = '';
  let registry = '';

  actions.forEach(a => {
    const fromPath = path.dirname(path.join(root, 'src/actions/actionRegistry.js'));
    const importPath = './' + path.relative(fromPath, a.module).replace(/\.ts$/, '').replace(/\\/g, '/');
    imports += `import { ${a.name} } from '${importPath}';\n`;
    registry += `  ${a.name},\n`;
  });

  const out = `// AUTO-GENERATED BY ABRA CLI — DO NOT EDIT MANUALLY
${imports}
const actionRegistry = {
${registry}};
export default actionRegistry;`;

  const file = path.join(root, 'src/actions/actionRegistry.js');
  fs.mkdirSync(path.dirname(file), { recursive: true });
  fs.writeFileSync(file, out);
  console.log(`✅ Wrote actionRegistry.js`);
}

function writeExecutor(root) {
  const out = `// AUTO-GENERATED BY ABRA CLI — DO NOT EDIT MANUALLY
import actionRegistry from './actionRegistry';

export async function executeAction(actionName, params) {
  const fn = actionRegistry[actionName];
  if (!fn) throw new Error(\`Action "\${actionName}" is not registered.\`);
  try {
    const result = await fn(params);
    return { success: true, result };
  } catch (err) {
    return { success: false, error: err.message };
  }
}
`;

  const file = path.join(root, 'src/actions/abra-executor.js');
  fs.mkdirSync(path.dirname(file), { recursive: true });
  fs.writeFileSync(file, out);
  console.log(`✅ Wrote abra-executor.js`);
}

function writeAbraComponent(root) {
  const out = `// AUTO-GENERATED BY ABRA CLI — DO NOT EDIT MANUALLY
import React, { useState } from "react";
import actionsJson from '../actions/actions.json';
import { executeAction } from '../actions/abra-executor';

const BACKEND_URL = "http://localhost:4000";

export function AbraActionPrompt() {
  const [input, setInput] = useState("");
  const [status, setStatus] = useState("");
  const [result, setResult] = useState(null);
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleExecute = async () => {
    setIsLoading(true); setStatus("Resolving action...");
    try {
      const res = await fetch(\`\${BACKEND_URL}/api/resolve-action\`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userIntent: input, actions: actionsJson.actions })
      });
      const aiResponse = await res.json();
      const executionResult = await executeAction(aiResponse.action, aiResponse.params);
      if (executionResult.success) {
        setResult(executionResult.result);
        setStatus(\`✅ Executed: \${aiResponse.action}\`);
      } else throw new Error(executionResult.error);
    } catch (err) {
      setError(err.message); setStatus("Failed");
    } finally { setIsLoading(false); }
  };

  return (<div className="abra-container">
    <input value={input} onChange={(e) => setInput(e.target.value)} disabled={isLoading} />
    <button onClick={handleExecute} disabled={isLoading}>Execute</button>
    {status && <p>{status}</p>}
    {error && <p>{error}</p>}
    {result && <pre>{JSON.stringify(result, null, 2)}</pre>}
  </div>);
}`;

  const file = path.join(root, 'src/components/AbraActionPrompt.jsx');
  fs.mkdirSync(path.dirname(file), { recursive: true });
  fs.writeFileSync(file, out);
  console.log(`✅ Wrote AbraActionPrompt.jsx`);
}

// === Run CLI
const projectRoot = process.argv[2] || process.cwd();
main(projectRoot);
